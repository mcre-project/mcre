use std::{fs, path::PathBuf, process::Command};

use indexmap::IndexMap;
use jni::{
    InitArgsBuilder, JNIEnv, JavaVM,
    objects::{JObject, JString, JValueGen},
};
use mcdl::RootManifest;
use mcre_data::{
    block::{Block, BlockStateField, BlockStateFieldValues},
    state::{BlockState, OffsetType, StateValue},
};
use tokio::task;

const BLOCK_DATA_PATH: &str = "crates/mcre_data/blocks.json";
const BLOCK_STATE_DATA_PATH: &str = "crates/mcre_data/block_states.json";

#[tokio::main]
async fn main() {
    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    let manifest_dir = PathBuf::from(manifest_dir);
    let special_source_path = manifest_dir.join("SpecialSource-1.11.4.jar");
    let root_manifest = RootManifest::fetch().await.unwrap();
    let version_release = root_manifest
        .versions
        .into_iter()
        .find(|ver| ver.id == "1.21.10")
        .unwrap();

    let version_manifest = version_release.fetch_manifest().await.unwrap();

    let outdir = env!("OUT_DIR");
    let root_path = PathBuf::from(outdir).join("downloads");
    let main_path = root_path.join("mc.jar");
    let mappings_path = root_path.join("mappings.tsrg");

    if !root_path.exists() {
        fs::create_dir_all(&root_path).unwrap();
    }

    if !mappings_path.exists() {
        let mappings = version_manifest
            .downloads
            .client_mappings
            .download_as_string()
            .await
            .unwrap();
        let mappings = mcdl::convert_mappings(&mappings);
        fs::write(&mappings_path, &mappings).unwrap();
    }

    if !main_path.exists() {
        let main_obfs_path = root_path.join("mc-obfs.jar");
        if !main_obfs_path.exists() {
            let client = version_manifest.downloads.client.download().await.unwrap();
            fs::write(&main_obfs_path, client).unwrap();
        }

        let java_home = java_locator::locate_java_home().unwrap();
        let mut java_home = PathBuf::from(java_home);
        java_home.push("bin");
        java_home.push("java");
        let output = Command::new(java_home)
            .args([
                "-jar",
                special_source_path.to_str().unwrap(),
                "--in-jar",
                main_obfs_path.to_str().unwrap(),
                "--out-jar",
                main_path.to_str().unwrap(),
                "--srg-in",
                mappings_path.to_str().unwrap(),
                // remove the local variable table so their names are generated by our decompiler
                "--kill-lvt",
            ])
            .output()
            .unwrap();

        assert!(output.status.success(), "Mapper failed");
    }

    let libs_root = root_path.join("libs");

    let mut classpath = main_path.to_str().unwrap().to_string();
    #[cfg(target_os = "windows")]
    let sep = ";";
    #[cfg(not(target_os = "windows"))]
    let sep = ":";

    let mut tasks = Vec::new();

    for lib in version_manifest.libraries {
        if lib.rules.iter().all(|rule| rule.allow()) {
            let name = lib.name.replace([';', ':'], "-");
            let lib_path = libs_root.join(if lib.name.ends_with(".jar") {
                name
            } else {
                format!("{}.jar", name)
            });
            classpath += &format!("{}{}", sep, lib_path.to_str().unwrap());
            if !lib_path.exists() {
                let task = task::spawn(async move {
                    println!("[DEBUG] Downloading: {}", lib.name);
                    let lib_source = lib.downloads.artifact.download().await.unwrap();
                    if let Some(parent) = lib_path.parent()
                        && !parent.exists()
                    {
                        tokio::fs::create_dir_all(parent).await.unwrap();
                    }
                    tokio::fs::write(&lib_path, lib_source).await.unwrap();
                });
                tasks.push(task);
            }
        }
    }

    for task in tasks {
        task.await.unwrap();
    }

    let jvm_args = InitArgsBuilder::new()
        .option(format!("-Djava.class.path={classpath}"))
        .build()
        .unwrap();

    let jvm = JavaVM::new(jvm_args).unwrap();
    let mut env = jvm.attach_current_thread().unwrap();

    init(&mut env);
    generate_block_data(&mut env);
    generate_block_state_data(&mut env);
}

fn generate_block_data(env: &mut JNIEnv) {
    println!("[DEBUG] Generating block data");
    let block_registry = get_registry(env, "BLOCK", "DefaultedRegistry");

    let block_state_registry = env
        .get_static_field(
            "net/minecraft/world/level/block/Block",
            "BLOCK_STATE_REGISTRY",
            "Lnet/minecraft/core/IdMapper;",
        )
        .unwrap()
        .l()
        .unwrap();

    let mut blocks = Vec::new();

    let mut block_state_id_counter = 0u16;

    iterate(&block_registry, env, |i, block, env| {
        let display_name = get_block_display_name(env, &block);
        let name = get_block_name(&block, &block_registry, env);
        let default_state = env
            .get_field(
                &block,
                "defaultBlockState",
                "Lnet/minecraft/world/level/block/state/BlockState;",
            )
            .unwrap()
            .l()
            .unwrap();

        let default_state_id = env
            .call_static_method(
                "net/minecraft/world/level/block/Block",
                "getId",
                "(Lnet/minecraft/world/level/block/state/BlockState;)I",
                &[JValueGen::Object(&default_state)],
            )
            .unwrap()
            .i()
            .unwrap() as u16;

        let states = get_block_states(&block, env);

        let min_state_id = block_state_id_counter;

        let mut owner = name.clone();

        while owner == name {
            block_state_id_counter += 1;
            let state = env
                .call_method(
                    &block_state_registry,
                    "byId",
                    "(I)Ljava/lang/Object;",
                    &[JValueGen::Int(block_state_id_counter as i32)],
                )
                .unwrap()
                .l()
                .unwrap();
            if state.is_null() {
                break;
            }
            let state_owner = env
                .get_field(state, "owner", "Ljava/lang/Object;")
                .unwrap()
                .l()
                .unwrap();
            let state_owner_name = get_block_name(&state_owner, &block_registry, env);
            owner = state_owner_name;
        }

        let max_state_id = block_state_id_counter - 1;

        blocks.push(Block {
            id: i as u16,
            name,
            display_name,
            default_state: default_state_id,
            min_state_id,
            max_state_id,
            states,
        });
    });
    println!("[DEBUG] Done!");

    let json_string = serde_json::to_string_pretty(&blocks).unwrap();
    let root = env!("CARGO_MANIFEST_DIR");
    let root = PathBuf::from(root);
    let data_path = root.join("../../").join(BLOCK_DATA_PATH);
    fs::write(&data_path, json_string).unwrap();

    println!("[DEBUG] Block data saved to `{}`", BLOCK_DATA_PATH);
}

fn generate_block_state_data(env: &mut JNIEnv) {
    println!("[DEBUG] Generating block state data");
    let block_registry = get_registry(env, "BLOCK", "DefaultedRegistry");

    let block_state_registry = env
        .get_static_field(
            "net/minecraft/world/level/block/Block",
            "BLOCK_STATE_REGISTRY",
            "Lnet/minecraft/core/IdMapper;",
        )
        .unwrap()
        .l()
        .unwrap();

    let mut block_state = env
        .call_method(
            &block_state_registry,
            "byId",
            "(I)Ljava/lang/Object;",
            &[JValueGen::Int(0)],
        )
        .unwrap()
        .l()
        .unwrap();

    let mut block_state_id = 0u16;

    let mut states = Vec::new();

    while !block_state.is_null() {
        let state = process_block_state(&block_registry, block_state_id, &block_state, env);
        states.push(state);
        block_state_id += 1;
        block_state = env
            .call_method(
                &block_state_registry,
                "byId",
                "(I)Ljava/lang/Object;",
                &[JValueGen::Int(block_state_id.into())],
            )
            .unwrap()
            .l()
            .unwrap();
    }

    println!("[DEBUG] Done!");

    let json_string = serde_json::to_string_pretty(&states).unwrap();
    let root = env!("CARGO_MANIFEST_DIR");
    let root = PathBuf::from(root);
    let data_path = root.join("../../").join(BLOCK_STATE_DATA_PATH);
    fs::write(&data_path, json_string).unwrap();

    println!(
        "[DEBUG] Block state data saved to `{}`",
        BLOCK_STATE_DATA_PATH
    );
}

fn process_block_state(
    block_registry: &JObject,
    id: u16,
    block_state: &JObject,
    env: &mut JNIEnv,
) -> BlockState {
    let block = env
        .get_field(block_state, "owner", "Ljava/lang/Object;")
        .unwrap()
        .l()
        .unwrap();

    let block_id: u16 = env
        .call_method(
            block_registry,
            "getId",
            "(Ljava/lang/Object;)I",
            &[JValueGen::Object(&block)],
        )
        .unwrap()
        .i()
        .unwrap()
        .try_into()
        .unwrap();

    let block_name = get_block_name(&block, block_registry, env);

    let light_emission: u8 = env
        .get_field(block_state, "lightEmission", "I")
        .unwrap()
        .i()
        .unwrap()
        .try_into()
        .unwrap();

    let use_shape_for_light_occlusion = env
        .get_field(block_state, "useShapeForLightOcclusion", "Z")
        .unwrap()
        .z()
        .unwrap();

    let propagates_skylight_down = env
        .get_field(block_state, "propagatesSkylightDown", "Z")
        .unwrap()
        .z()
        .unwrap();

    let light_block: u8 = env
        .get_field(block_state, "lightBlock", "I")
        .unwrap()
        .i()
        .unwrap()
        .try_into()
        .unwrap();

    let solid_render = env
        .get_field(block_state, "solidRender", "Z")
        .unwrap()
        .z()
        .unwrap();

    let is_air = env
        .get_field(block_state, "isAir", "Z")
        .unwrap()
        .z()
        .unwrap();

    let ignited_by_lava = env
        .get_field(block_state, "ignitedByLava", "Z")
        .unwrap()
        .z()
        .unwrap();

    let can_occlude = env
        .get_field(block_state, "canOcclude", "Z")
        .unwrap()
        .z()
        .unwrap();

    let is_randomly_ticking = env
        .get_field(block_state, "isRandomlyTicking", "Z")
        .unwrap()
        .z()
        .unwrap();

    let replaceable = env
        .get_field(block_state, "replaceable", "Z")
        .unwrap()
        .z()
        .unwrap();

    let spawn_terrain_particles = env
        .get_field(block_state, "spawnTerrainParticles", "Z")
        .unwrap()
        .z()
        .unwrap();

    let requires_correct_tool_for_drops = env
        .get_field(block_state, "requiresCorrectToolForDrops", "Z")
        .unwrap()
        .z()
        .unwrap();

    let destroy_speed = env
        .get_field(block_state, "destroySpeed", "F")
        .unwrap()
        .f()
        .unwrap();

    let offset_type = determine_offset_type(block_state, env);

    let state_values = get_state_values(block_state, env);

    BlockState {
        id,
        block_id,
        block_name,
        light_emission,
        use_shape_for_light_occlusion,
        propagates_skylight_down,
        light_block,
        solid_render,
        is_air,
        ignited_by_lava,
        can_occlude,
        is_randomly_ticking,
        replaceable,
        spawn_terrain_particles,
        requires_correct_tool_for_drops,
        destroy_speed,
        offset_type,
        state_values,
    }
}

pub fn determine_offset_type(block_state: &JObject, env: &mut JNIEnv) -> OffsetType {
    let offset_function = env
        .get_field(
            block_state,
            "offsetFunction",
            "Lnet/minecraft/world/level/block/state/BlockBehaviour$OffsetFunction;",
        )
        .unwrap()
        .l()
        .unwrap();

    if offset_function.is_null() {
        return OffsetType::None;
    }

    let block_pos_class = "net/minecraft/core/BlockPos";

    for i in 0..10 {
        // BlockPos(i, i, i)
        let pos_obj = env
            .new_object(
                block_pos_class,
                "(III)V",
                &[JValueGen::Int(i), JValueGen::Int(i), JValueGen::Int(i)],
            )
            .unwrap();

        // Call offsetFunction.evaluate(state, pos)
        // Signature: (LBlockState;LBlockPos;)LVec3;
        let vec3_obj = env.call_method(
            &offset_function,
            "evaluate",
            "(Lnet/minecraft/world/level/block/state/BlockState;Lnet/minecraft/core/BlockPos;)Lnet/minecraft/world/phys/Vec3;",
            &[JValueGen::Object(block_state), JValueGen::Object(&pos_obj)]
        ).unwrap().l().unwrap();

        let y_val = env.get_field(&vec3_obj, "y", "D").unwrap().d().unwrap();

        if y_val.abs() > 0.00001 {
            return OffsetType::XYZ;
        }
    }

    OffsetType::XZ
}

fn get_state_values(block_state: &JObject, env: &mut JNIEnv) -> IndexMap<String, StateValue> {
    let mut values = IndexMap::new();

    let properties = env
        .call_method(
            block_state,
            "getProperties",
            "()Ljava/util/Collection;",
            &[],
        )
        .unwrap()
        .l()
        .unwrap();

    iterate(&properties, env, |_i, property, env| {
        let property_clazz = env
            .get_field(&property, "clazz", "Ljava/lang/Class;")
            .unwrap()
            .l()
            .unwrap();

        let property_clazz_name = env
            .call_method(property_clazz, "getSimpleName", "()Ljava/lang/String;", &[])
            .unwrap()
            .l()
            .unwrap();

        let property_clazz_name = obj_to_str(property_clazz_name, env);

        let value = env.call_method(block_state, "getValue", "(Lnet/minecraft/world/level/block/state/properties/Property;)Ljava/lang/Comparable;", &[JValueGen::Object(&property)]).unwrap().l().unwrap();
        let key_obj = env
            .get_field(&property, "name", "Ljava/lang/String;")
            .unwrap()
            .l()
            .unwrap();
        let key = obj_to_str(key_obj, env);
        let value_obj = env
            .call_method(
                &property,
                "getName",
                "(Ljava/lang/Comparable;)Ljava/lang/String;",
                &[JValueGen::Object(&value)],
            )
            .unwrap()
            .l()
            .unwrap();
        let value_string = obj_to_str(value_obj, env);

        let value = match property_clazz_name.as_str() {
            "Integer" => StateValue::Int(value_string.parse().unwrap()),
            "Boolean" => StateValue::Bool(value_string.parse().unwrap()),
            "String" => {
                panic!("No schema");
            }
            _ => StateValue::String(value_string),
        };
        values.insert(key, value);
    });

    values
}

fn iterate<'a>(
    obj: &JObject<'a>,
    env: &'a mut JNIEnv,
    mut cb: impl FnMut(usize, JObject<'a>, &mut JNIEnv),
) {
    let iterator = env
        .call_method(obj, "iterator", "()Ljava/util/Iterator;", &[])
        .unwrap()
        .l()
        .unwrap();

    let mut i = 0;
    loop {
        // call hasNext()
        let has_next = env
            .call_method(&iterator, "hasNext", "()Z", &[])
            .unwrap()
            .z()
            .unwrap();
        if !has_next {
            break;
        }

        // call next()
        let element = env
            .call_method(&iterator, "next", "()Ljava/lang/Object;", &[])
            .unwrap()
            .l()
            .unwrap();

        cb(i, element, env);

        i += 1;
    }
}

fn init(env: &mut JNIEnv) {
    let detected_version_built_in = env
        .get_static_field(
            "net/minecraft/DetectedVersion",
            "BUILT_IN",
            "Lnet/minecraft/WorldVersion;",
        )
        .unwrap()
        .l()
        .unwrap();

    println!("[DEBUG] Calling: SharedConstants.setVersion(DetectedVersion.BUILT_IN);");
    env.call_static_method(
        "net/minecraft/SharedConstants",
        "setVersion",
        "(Lnet/minecraft/WorldVersion;)V",
        &[JValueGen::Object(&detected_version_built_in)],
    )
    .unwrap();

    println!("[DEBUG] Calling: Bootstrap.bootStrap();");
    env.call_static_method("net/minecraft/server/Bootstrap", "bootStrap", "()V", &[])
        .unwrap();
}

fn get_registry<'a>(env: &mut JNIEnv<'a>, name: &str, jtype: &str) -> JObject<'a> {
    let built_in_registries = env
        .find_class("net/minecraft/core/registries/BuiltInRegistries")
        .unwrap();

    env.get_static_field(
        built_in_registries,
        name,
        format!("Lnet/minecraft/core/{jtype};"),
    )
    .unwrap()
    .l()
    .unwrap()
}

fn get_block_display_name(env: &mut JNIEnv, block: &JObject) -> String {
    let display_name_component = env
        .call_method(
            block,
            "getName",
            "()Lnet/minecraft/network/chat/MutableComponent;",
            &[],
        )
        .unwrap()
        .l()
        .unwrap();

    let display_name_obj = env
        .call_method(
            display_name_component,
            "getString",
            "()Ljava/lang/String;",
            &[],
        )
        .unwrap()
        .l()
        .unwrap();

    obj_to_str(display_name_obj, env)
}

fn get_block_name(block: &JObject, block_registry: &JObject, env: &mut JNIEnv) -> String {
    let block_resource_key = env
        .call_method(
            block_registry,
            "getKey",
            "(Ljava/lang/Object;)Lnet/minecraft/resources/ResourceLocation;",
            &[JValueGen::Object(block)],
        )
        .unwrap()
        .l()
        .unwrap();
    get_resource_location_key_name(&block_resource_key, env)
}

fn get_resource_location_key_name(resource_location: &JObject, env: &mut JNIEnv) -> String {
    let name_obj = env
        .get_field(resource_location, "path", "Ljava/lang/String;")
        .unwrap()
        .l()
        .unwrap();
    obj_to_str(name_obj, env)
}

fn obj_to_str(obj: JObject, env: &mut JNIEnv) -> String {
    let jstr = JString::from(obj);
    env.get_string(&jstr).unwrap().into()
}

fn get_block_states(block: &JObject, env: &mut JNIEnv) -> Vec<BlockStateField> {
    let state_definition = env
        .get_field(
            block,
            "stateDefinition",
            "Lnet/minecraft/world/level/block/state/StateDefinition;",
        )
        .unwrap()
        .l()
        .unwrap();

    let properties_map = env
        .get_field(
            state_definition,
            "propertiesByName",
            "Lcom/google/common/collect/ImmutableSortedMap;",
        )
        .unwrap()
        .l()
        .unwrap();

    let properties_map_entry_set = env
        .call_method(
            properties_map,
            "entrySet",
            "()Lcom/google/common/collect/ImmutableSet;",
            &[],
        )
        .unwrap()
        .l()
        .unwrap();

    let mut states = Vec::new();

    iterate(&properties_map_entry_set, env, |_i, entry, env| {
        let name_obj = env
            .call_method(&entry, "getKey", "()Ljava/lang/Object;", &[])
            .unwrap()
            .l()
            .unwrap();

        let name = obj_to_str(name_obj, env);

        let property = env
            .call_method(entry, "getValue", "()Ljava/lang/Object;", &[])
            .unwrap()
            .l()
            .unwrap();

        let property_clazz = env
            .get_field(&property, "clazz", "Ljava/lang/Class;")
            .unwrap()
            .l()
            .unwrap();

        let property_clazz_name = env
            .call_method(property_clazz, "getSimpleName", "()Ljava/lang/String;", &[])
            .unwrap()
            .l()
            .unwrap();

        let property_clazz_name = obj_to_str(property_clazz_name, env);

        let values = match property_clazz_name.as_str() {
            "Integer" => {
                let min: u8 = env
                    .get_field(&property, "min", "I")
                    .unwrap()
                    .i()
                    .unwrap()
                    .try_into()
                    .unwrap();
                let max: u8 = env
                    .get_field(&property, "max", "I")
                    .unwrap()
                    .i()
                    .unwrap()
                    .try_into()
                    .unwrap();

                BlockStateFieldValues::Int { min, max }
            }
            "Boolean" => BlockStateFieldValues::Bool,
            "String" => {
                panic!("No schema");
            }
            _ => {
                let possible_values = env
                    .call_method(&property, "getPossibleValues", "()Ljava/util/List;", &[])
                    .unwrap()
                    .l()
                    .unwrap();

                let mut values = Vec::new();

                iterate(&possible_values, env, |_i, value, env| {
                    let value_name_obj = env
                        .call_method(
                            &property,
                            "getName",
                            "(Ljava/lang/Comparable;)Ljava/lang/String;",
                            &[JValueGen::Object(&value)],
                        )
                        .unwrap()
                        .l()
                        .unwrap();

                    let value_name = obj_to_str(value_name_obj, env);

                    values.push(value_name);
                });

                BlockStateFieldValues::Enum {
                    enum_name: property_clazz_name,
                    values,
                }
            }
        };

        states.push(BlockStateField { name, values })
    });

    states
}
